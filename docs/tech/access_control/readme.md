# アクセスコントロール技術

* 複雑なので個別に説明

## 最初にまとめ

* 権限管理を、以下で実装している
  * ユーザ・グループ・ティア（ロール）を使って、継承コンテキスト（リソースに対して複数設定可能）毎に制御できるRBAC
    * 例外規則として、個別のユーザ・グループ・ティアに対する優先権限判定を登録可能
  * 上記RBACで判定できない場合はABACで判定

## 理解のために(このドキュメントを読む前に読んでください)

* [簡単な仕様説明](./00_simple_explanation.md)
* [利用例](./01_example_usage.md)
* [データ構造](./02_data_structure.md)
* [判定アルゴリズム](./03_judgment_algorithm.md)

## できること

このシステムは、単なる「許可/拒否」だけでなく、**「いつ、どこで、誰が、どの役割で、何をできるか」**を非常に細かく制御するために設計されています。

---

### 1. 「場所」によってユーザーの「役割（Tier）」を変える

これがこのシステム**最大の特徴**です。

* **例:** ユーザーAさんは、
    * 「全社」の場所（コンテキスト）では「一般社員Tier」
    * 「プロジェクトX」の場所（コンテキスト）では「リーダーTier」
    * 「監査チーム」の場所（コンテキスト）では「閲覧者Tier」
    といった複数の役割（Tier）を同時に持つことができます。
* 権限チェック（`isAllowed`）は、常に「今いる場所（コンテキスト）で、この人の役割は何か？」を自動的に判断して行われます。

### 2. 権限を「継承」させて、管理を楽にする

* 「親フォルダ」と「子ファイル」のように、ルールブック（コンテキスト）に親子関係（`parent_id`） を持たせることができます。
* **例:** 「親フォルダ」に「Aさん閲覧許可」ルールを設定しておけば、その中にあるすべての子ファイルや孫フォルダにも、そのルールが自動的に引き継がれます。一つひとつに設定する手間が省けます。

### 3. 強力な「例外ルール」を設定する

「全体を許可しつつ、特定の人だけ拒否する」といった複雑な例外処理が可能です。

* **① 拒否優先 (Deny Overrides):**
    * **例:** 「開発グループ」全体に「閲覧許可」を与えていても、もし「ユーザーB」個人に「閲覧拒否」 ルールが1つでもあれば、Bさんは**絶対に閲覧できません**。拒否が常に優先されます。
* **② 優先度 (`orderno`):**
    * **例:** 「グループの許可ルール（優先度10）」と「個人の拒否ルール（優先度5）」が同時に存在する場合、`orderno` の数字が小さい「個人の拒否ルール」が優先されます。

### 4. 「本人」や「所属」に基づく権限を与える (ABAC)

ルールブック（RBAC）では許可されていなくても、「モノと本人の関係性」に基づいて許可を与えることができます。

* **例:**
    * 「**自分自身**のプロフィールは編集できる」
    * 「**自分が所属するグループ**のメンバー一覧は見れる」
* これは、継承ルールをすべてチェックしても許可/拒否が決まらなかった場合の、最終チェック（`isAllowedSelf`） として機能します。

### 5. 非常に細かい粒度で権限を定義する

* **例:** 同じ「ユーザー情報」というリソースに対しても、
    * `user.get`: 基本情報（名前など）の取得
    * `user.getDetails`: 詳細情報（メールアドレスなど）の取得
    * `user.get_sensitive`: 機密情報（ログインIDなど）の取得
    といったように、操作（アクション）を細かく分けて定義できます。
* これにより、「Aさんは名前だけ見れるが、Bさん（管理者）はメールアドレスまで見れる」といった詳細な制御が可能です。

### 6. 効率的な権限チェック

* **一括チェック:** `usermapping` のように、一度に複数の権限（`user.get`, `user.getDetails`など）が必要な場合、`isMultipleAllowed` を使って、重い計算（Tierの計算など）を1回で済ませ、効率的に一括チェックできます。
* **キャッシュ:** 一度行った権限チェックの結果や計算途中のデータは、すべてキャッシュ（高速な記憶装置）に保存され、2回目以降のチェックを高速化します。

## できないこと

### 1. 時間ベースのアクセス制御 (TBAC)

このシステムは「いつ」アクセスしているかを考慮しません。

* **できないこと:**
    * 「平日の9時〜17時だけアクセスを許可する」
    * 「2025年12月31日までの期間限定でアクセスを許可する」
* **理由:**
    `access_rules` や関連するテーブルに「開始日時」「終了日時」といった時間のを保存するカラムが存在せず、`isAllowed` アルゴリズムも現在時刻をチェックするロジックを持っていません。

---

### 2. 場所ベースのアクセス制御 (LBAC)

このシステムは「どこから」アクセスしているかを考慮しません。

* **できないこと:**
    * 「社内のIPアドレスからのみアクセスを許可する」
    * 「特定の国（例: 日本国内）からのアクセスのみ許可する」
* **理由:**
    `isAllowed` アルゴリズムは、リクエスト元のIPアドレスや地理情報を引数として受け取っておらず、それに基づいてルールを判断する仕組みがありません。

---

### 3. リソースの状態やリクエスト内容に基づく動的な制御

`isAllowedSelf` によるABAC（属性ベース）は、「操作者とリソースの所有者が同じか」といった**静的な属性**の比較 に限定されています。より動的な条件の制御はできません。

* **できないこと:**
    * 「記事にコメントが1件以上ついている場合、その記事の削除（`tree.delete`）を禁止する」
    * 「リクエストされた金額が10万円以上の場合、`tier=manager` でないと許可しない」
    * 「リソースの `status` が `published` の場合のみ `edit` を許可する」
* **理由:**
    `isAllowed` は、リソースの`target_id` は受け取りますが、そのリソースの**現在の内容（ステータス、子要素の数など）**や、リクエストの**中身（POSTされたJSONデータなど）**を読み取ってルールを動的に評価する、汎用的なルールエンジンとしては設計されていません。

---

### 4. 職務分掌 (SoD) のような制約

このシステムは「権限を与える」ことは得意ですが、「権限間の競合を防ぐ」ことはできません。

* **できないこと:**
    * 「『申請者』Tierと『承認者』Tierを、同一ユーザーが同時に持つことを禁止する」
    * 「リソースを作成したユーザーが、自分自身でそのリソースを『承認』操作することを禁止する」
* **理由:**
    これらは個別の権限チェック（`isAllowed`）ではなく、複数のTierや操作ログにまたがるビジネスロジック上の制約です。`access.js` はこのような制約を管理する機能を持っておらず、アプリケーション本体側での実装が必要になります。

## 特徴

### 1. 圧倒的な柔軟性と詳細な粒度

* **コンテキスト依存Tier（役割）:** このシステムの最大の利点です。ユーザーのTier（役割）が固定的ではなく、アクセス先の「コンテキスト（場所）」によって動的に変わります。これにより、「プロジェクトAではリーダーだが、全社コンテキストでは一般社員」といった、現実に即した非常にきめ細かな権限設定が可能です。
* **RBAC + ABAC のハイブリッド:** 基本は「ユーザー」「グループ」「Tier」に基づくRBAC（ロールベース制御） ですが、それが失敗した場合に「リソースの所有者か？」などをチェックするABAC（属性ベース制御） がフォールバックとして機能します。これにより、両方のモデルの良い部分（管理しやすさと柔軟性）を両立しています。
* **継承コンテキスト:** ルールブック（コンテキスト）が親子関係を持つ ため、「親フォルダ」で設定したルールが「サブフォルダ」にも自動的に引き継がれます。これにより、管理の重複を避け、ルール設定を大幅に簡素化できます。
* **複数のコンテキスト設定:** 1つのリソース（モノ）が複数のコンテキスト（ルールブック）を持つことができる ため、異なる権限体系を1つのリソースに同時に適用することも可能です。

### 2. 高い安全性と予測可能性

* **拒否優先 (Deny Overrides):** アルゴリズムは「拒否（`is_allow = false`）」 を最優先します。継承チェーンのどこか1ヶ所にでも拒否ルールがあれば、他の許可ルールをすべて無視して即座にアクセスを拒否します。これにより、意図しない権限付与を防ぐ、最も安全な設計（セキュア・バイ・デフォルト）が実現されています。
* **デフォルト拒否 (Default Deny):** `access_rules` にも `isAllowedSelf`（ABAC） にも該当するルールが一切見つからなかった場合、最終的な判断は「拒否」となります。明示的に許可されていない操作は実行できないため、安全です。

### 3. 高度な例外管理

* **優先権限判定 (`orderno`):** 「拒否優先」の前に、`orderno`（優先度番号） による優先度判定が挟まれます。これにより、「グループ全体（`orderno=10`）は許可するが、例外として特定のユーザー（`orderno=5`）だけは拒否する」といった、直感的で強力な例外ルールの設定が可能です。

### 4. 優れたパフォーマンス

* **積極的かつ多層的なキャッシュ戦略:**
    * `isAllowed` の最終結果 という「出口」だけでなく、`getGroupIdsByUser`、`getParentContextId`、`getTierIdsByUser` など、計算の「途中経過」も徹底的にキャッシュします。
    * 特にTier計算では、「グループ単体」 と「グループリスト」 の2層でキャッシュを持つなど、非常に効率的な設計になっています。
* **効率的なDBアクセス:** 権限チェックの核となる`access_rules` の検索は、`orderBy('orderno', 'asc').limit(1)` を使い、DBから取得するデータを最小限（各階層で1件）に抑えています。これにより、キャッシュミス時でもDB負荷を最小限に留めます。
* **一括チェックへの最適化:** `isMultipleAllowed` により、複数の権限（例: `user.get`, `user.getDetails`）をチェックする際も、重い事前準備（`context_id` や `tier_ids` の計算）を**1回**で済ませるよう最適化されています。

## 解説

### 権限管理モデル：総括

このシステムは、**「Context依存RBAC＋ABAC」**のハイブリッド型アクセス制御モデルを実装している、と考えるのが最も正確です。

具体的には、以下の要素で構成されています。

1.  **RBAC（ロールベース・アクセス制御）が基本:**
    権限ルールの基本単位は「**ユーザ**」「**グループ**」「**ティア（ロール）**」です。これが権限管理の基盤（RBAC）となります。

2.  **コンテキストによる制御:**
    * **継承コンテキスト:** ルールは「コンテキスト」という階層構造を持つ「ルールブック」に保存されます。権限チェック時には、この階層を親に向かって遡ってルールを検索します（継承）。
    * **複数設定可能:** 1つのリソース（モノ）が、複数のコンテキスト（ルールブック）を持つことができます。
    * **コンテキスト毎の制御 (最重要):** このシステムのRBACが強力なのは、**ユーザーが持つTier（ロール）自体が、今チェックしているコンテキスト（`cid`）によって動的に変わる** 点です。`map_usertier` や `map_grouptier` が `context_id` を持つため、「プロジェクトAではリーダーだが、プロジェクトBではメンバー」といった制御が可能になっています。

3.  **2段階の例外規則（優先権限判定と拒否優先）:**
    このシステムは、例外を処理するために2つの仕組みを組み合わせています。

    * **① 優先権限判定 (`orderno`):**
        まず、`access_rules` テーブルにある `orderno`（優先度番号） が、**「どのルールが最も強いか」**を決定します。
        例えば、「グループ全体を許可（`orderno=10`）」というルールがあっても、「特定のユーザーだけを拒否（`orderno=5`）」という、より`orderno`が小さい（優先度が高い）ルールを登録することで、**個別のユーザ・グループ・ティアに対する優先権限**を実現できます。
        `isAllowed` アルゴリズムは、`orderBy('orderno', 'asc').limit(1)` を使い、常にこの「最も優先度の高いルール1件」だけを見つけ出します。

    * **② 拒否優先（Deny Overrides）:**
        次に、上記①の`orderno`判定によって選ばれた「最も優先度の高いルール」が、もし `is_allow = false`（拒否） だった場合、これが**最終的な例外規則**として機能します。
        アルゴリズムは、この「拒否」ルールを見つけた瞬間に他のすべてのチェックを中断し、即座にアクセスを**拒否**します。

4.  **ABAC（属性ベース・アクセス制御）によるフォールバック:**
    上記のRBACおよび例外規則の継承チェーンをすべて遡ってもルールが見つからなかった場合（`allowed === null`）、最後に `isAllowedSelf` が呼び出されます。
    これは、渡された `selfObject` の属性（リソースの所有者ID など）と、操作ユーザーの属性（`userid` など）を比較する **ABAC** として機能します。

---

**結論として:**
ご提示いただいた通り、この実装は**「ユーザ・グループ・ティア（ロール）を使った、継承コンテキスト（リソースに複数設定可能）毎に制御できるRBAC（例外規則として、個別のユーザ・グループ・ティアに対する優先権限判定(`orderno`)と、それによって決定されたルールの拒否優先(`is_allow=false`)を登録可能）＋ABAC」** と考えるのが、最も正確な理解です。

## 参考情報

* [アクション一覧](./10_action_list.md)



