はい、access.js の中核である権限チェック関数 isMultipleAllowed (単一チェックの isAllowed も内部でこれを呼び出します) が、具体的にどのような手順（アルゴリズム）で権限を判断しているかを説明します。

仕様、使い方、データ構造を理解されている前提で、コードの動きを追っていきましょう。

---

## **isMultipleAllowed アルゴリズム解説 ⚙️**

この関数は、**「誰が (userid)」「どのモノ (target, target\_id) に対して」「複数の操作 (action\_names) をして良いか」** を効率的にチェックします。

**ステップ 1: メインキャッシュの確認 (超高速チェック) ⚡**

1. まず、\*\*「このユーザー、このモノ、この操作リストの組み合わせ」\*\*の最終結果がキャッシュ (例: rules:isAllowed:TREE:10 キーの 5:action1,action2 フィールド) に保存されていないか確認します。  
2. もしキャッシュがあれば、DBアクセスなしで即座に結果 ({action1: true, action2: false} など) を返して終了します。

---

**ステップ 2: 事前準備 (必要な情報を集める) 📝**

キャッシュがなかった場合、本格的なチェックの前に、必要な情報を集めます (これも多くがキャッシュされます)。

1. **モノの特定:** target と target\_id (例: TREE, 10\) から、resources テーブルの id (例: 15\) を取得します。  
2. **ルールブックの特定:** resource\_id (15) から、map\_resource\_context テーブルを引いて、このモノに関連付けられた「ルールブック」(context\_ids のリスト、例: \[8, 12\]) を取得します。  
3. **グループ情報の取得:** 操作するユーザー (userid) が所属する全グループ (group\_ids のリスト) を取得します。  
4. **Tier (役割) 情報の事前計算 (重要):**  
   * 取得した context\_ids (\[8, 12\]) それぞれについて、**「このユーザーが、このコンテキストにおいて有効なTierは何か？」** を事前に計算し、マップ (tier\_ids\[cid\]) に格納します。 (例: tier\_ids\[8\] \= \[2\], tier\_ids\[12\] \= \[2, 5\])  
   * もし、この計算過程で「明確な拒否」を示す値 (-2 など) が返ってきたら、その時点で全アクションを拒否として終了します。

---

**ステップ 3: 各アクションの権限チェック (ループ処理) 🔄**

チェックしたい操作 (action\_names) のリストを一つずつ処理します。

1. **個別キャッシュ確認:** まず、この**個別のアクション** (例: tree.list) の結果がキャッシュ (rules:isAllowed:TREE:10 キーの 5:tree.list フィールド) にないか確認します。あればそれを使って次のアクションへ。  
2. **アクションIDの取得:** アクション名 (例: tree.list) に対応する actions テーブルの id (例: 3\) を取得します (これもキャッシュされます)。  
3. **継承チェーンの走査 (while ループ) 🪜:**  
   * 最初に取得した context\_ids (\[8, 12\]) からスタートします。  
   * **現在の階層にあるコンテキストをチェック (for ループ) 🔍:**  
     * current\_context\_ids (\[8, 12\]) を一つずつ (cid \= 8, 次に cid \= 12\) 処理します。  
     * **ルール検索 (DBアクセス \- limit 1):** access\_rules テーブル に対して、以下の条件で**最も優先度の高い (ordernoが小さい) ルールを1件だけ**検索します。  
       * action\_id が一致  
       * context\_id が cid (今見ているコンテキストID) に一致  
       * ルール (unit) が、操作ユーザー (userid)、所属グループ (group\_ids)、**このコンテキストで有効なTier (tier\_ids\[cid\])**、または全員 (UNIT\_ALL) のいずれかに該当する  
     * **拒否優先ルールの適用:**  
       * もし見つかったルールが「**拒否** (is\_allow \= false)」なら、他のルールを無視して**即座にこのアクションは「拒否 (false)」と決定**し、for ループと while ループを抜けます (found \= false; break;)。  
       * もし見つかったルールが「**許可** (is\_allow \= true)」なら、とりあえず found \= true と記録しておきます (同じ階層の他のコンテキストで拒否が見つかるかもしれないため)。  
   * **次の階層へ:**  
     * 現在の階層 (current\_context\_ids) で拒否ルールが見つからず (found \!== false)、かつ許可ルールも見つからなかった (found \=== null) 場合、現在の各コンテキストの親 (getParentContextId) を取得し、それを次の current\_context\_ids として while ループを続けます。  
     * もし親が \-1（ルート到達） なら、継承は終了です。  
     * もし親が \-2（明確な拒否） なら、その時点でこのアクションは「拒否」と決定します。  
     * 許可ルールが見つかっていた (found \=== true) 場合は、その時点でこのアクションは「許可 (true)」と決定し、while ループを抜けます。

---

**ステップ 4: フォールバックと最終決定 🏁**

1. **ABAC (属性ベース) チェック:** while ループで継承をたどりきってもルールが見つからなかった場合 (allowed \=== null)、isAllowedSelf 関数 を呼び出し、「自分自身のモノか？」などの属性ベースのチェックを行います。  
2. **デフォルト拒否:** それでもルールが見つからなければ、最終的に\*\*「拒否 (false)」\*\*と決定します。

---

**ステップ 5: 結果のキャッシュと返却 💾**

1. 各アクションごとに決定された結果 (true / false) は、**個別のアクションキー** (例: 5:tree.list) でメインキャッシュに保存されます。  
2. 全てのアクションのチェックが終わったら、**全アクションの結果をまとめたオブジェクト** (例: { 'tree.list': true, 'tree.update': false }) を、**最初に確認した複合キー** (例: 5:tree.list,tree.update) でもキャッシュに保存します。  
3. 最終的な結果オブジェクトを呼び出し元に返します。

---

このアルゴリズムにより、複雑な継承、場所によって変わる役割（Tier）、拒否優先ルール、属性ベースのチェックを効率的に処理しつつ、キャッシュを活用して高速な応答を実現しています。
