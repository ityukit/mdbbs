#簡単な仕様説明

---

## アクセス制御（`access.js`）の簡単な仕様説明

このアクセス制御（誰が何をしていいかを決める仕組み）の仕様について、初めて見る方にもわかりやすく説明します。

このシステムは、**「誰が」「どのモノ（場所）に対して」「何の操作を」** して良いかを、非常に細かく決めるためのものです。

---

### 1. 基本的な考え方：「モノ」と「ルールブック」 🧱📚

まず、システムには大きく分けて2つの要素があります。

* **リソース (Resource):** 権限で保護したい「モノ」のことです。例えば、「投稿ツリーA」とか「ユーザーBのプロフィール」とか、「グループC」などがこれにあたります。
* **コンテキスト (Context):** そのリソースに適用される「ルールブック」のようなものです。このルールブックの中に、具体的な権限ルール（`access_rules`） がたくさん書かれています。

**ポイント:** 「モノ（リソース）」と「ルールブック（コンテキスト）」は**別々に管理**されます。これにより、複数のモノで同じルールブックを共有する、といった柔軟な管理が可能です。

---

### 2. 権限の「内容」：「何を」許可するのか？ (Read/Writeなど) ✍️👀

このシステムを理解する上で非常に重要な点です。

* このシステムには、「Read（読み取り）」や「Write（書き込み）」といった**決まった権限は存在しません。**
* 代わりに、すべての操作は「**アクション (Action)**」と呼ばれる単純な文字列として定義されます。
* 例えば、以下のように、アプリケーションの（`db/migrations`や`db/seeds` 内の`actions.js`ファイル などで）自由に定義します。
    * `tree.list` （ツリーの一覧表示 = Read）
    * `tree.update` （ツリーの更新 = Write）
    * `user.get` （ユーザーの基本情報取得 = Read）
    * `user.getDetails` （ユーザーの詳細情報取得 = Read (強)）
    * `user.get_sensitive` （機密情報の取得 = Read (最強)）

**ポイント:**
アプリケーション側が「今からツリーの一覧表示をするぞ」という時に、`access.js` に対して**「`tree.list` の権限を持っていますか？」**と問い合わせる ことで、権限チェックが成立します。これにより、`user.getDetails` のような非常に細かい粒度での権限管理が可能になっています。

---

### 3. 「誰が」アクセスできるか？：ユーザー・グループ・Tier（役割） 👤👥👑

上記のアクション（例: `tree.list`）を、「誰が」実行できるかは、以下の単位でルールブック（`access_rules`）に書き込まれます。

1.  **特定のユーザー:** 「ユーザーID: 5 の人だけ許可」。
2.  **特定のグループ:** 「開発部グループ（とその親グループ）に所属する人は許可」。
3.  **特定のTier（役割）:** 「管理者Tier（ロール）を持つ人は許可」。
4.  **全員:** 「ログインしていれば誰でもOK」。

**特に重要な点（Context依存Tier）:**
このシステムのユニークな点は、**Tier（役割）が場所（コンテキスト）によって変わる**ことです。
例えば、Aさんは「プロジェクトXの場所ではリーダーTier」だけど、「会社全体では一般社員Tier」といった設定が可能です。権限チェックの際は、**今いる場所（コンテキスト）で有効なTier**を正しく使って判断します。

---

### 4. ルールの継承：「親のルールは子のルール」 👨‍👩‍👧‍👦

このシステムのもう一つの大きな特徴が「**継承**」です。

* ルールブック（コンテキスト）には親子関係があります。
* あるモノ（例: 「企画書ファイル」）の権限をチェックするとき、まずそのモノに直接関連付けられたルールブックを見ます。
* そこにルールがなければ、親のルールブック、さらにその親のルールブック…と、**先祖をたどってルールを探します**。

---

### 5. ルールの優先順位：「ダメ」が一番強い！ 🚫👍

ルールが複数見つかったり、矛盾したりする場合のルールです。

1.  **拒否優先 (Deny Overrides):**
    継承をたどる中で、**1つでも「禁止（`is_allow = false`）」のルールが見つかれば、他のどんな許可ルールがあっても即座に「アクセス禁止」**と決定されます。
2.  **優先権限判定 (`orderno`):**
    同じ階層に「許可」と「拒否」が両方ある場合、`orderno` という優先度番号が小さいルールが採用されます。
3.  **自分自身ルール (ABAC):**
    継承ルールで許可も拒否もされなかった場合、「**自分自身**のプロフィールは編集できるか？」といった、モノと本人の関係性に基づく特別なルール（`isAllowedSelf`） でチェックされます。
4.  **デフォルト拒否 (Default Deny):**
    上記のどのルールにも当てはまらなかった場合、最終的には**「アクセス禁止」**となります。

---

### 【修正版】6. 有効フラグによる制御 🚦

このシステムは、権限チェックのあらゆる段階で「**それが今、有効か？**」を確認します。

* **ユーザー:** 操作するユーザー自身が無効な（`is_enabled = false`）場合、他のルールを評価する前に**即座に「拒否」**されます。
* **グループ・Tier・コンテキスト:** ユーザーが無効でない場合、権限の計算が開始されますが、その際に無効な（`is_enabled = false`）グループ、Tier（役割）、コンテキスト（ルールブック） は、**すべて「無かったもの」として無視されます。**

これにより、管理者がユーザーやグループを「無効」にするだけで、そのエンティティを経由した権限が（拒否されるのではなく）計算対象から除外され、安全かつ柔軟にアクセスを管理できます。

---

### 7. キャッシュによる高速化 ⚡

この権限チェックは非常に複雑ですが、一度計算した結果や途中で必要になる情報（ユーザーの所属グループリストなど）は、**キャッシュ**（高速な一時記憶装置）に保存されます。

これにより、2回目以降のアクセスではデータベースへの問い合わせを大幅に減らし、**高速に応答できる**ようになっています。

---

## まとめ

* このシステムは、リソースに紐づく「継承コンテキスト」ごとに「有効な」ユーザ・グループ・Tier（役割）が変動する、拒否優先型（is_allow=false）かつ優先度（orderno）ベースのRBACに、ABAC（isAllowedSelf）を組み合わせたハイブリッド型アクセス制御です。

このシステムは、場所（コンテキスト）ごとにルールブックを用意し、親子関係でルールを継承します。最大の特徴は、ユーザーの役割（Tier）も場所によって変わることで、権限は常にその場所での役割で判断されます。

ルールの判定は、まず優先度（orderno） に基づく**「優先権限判定」**で行われ、そこで見つかったルールが「禁止」だった場合は、他の何よりも最優先（拒否優先）されます。

継承ルールで許可も拒否も見つからなかった場合は、「自分自身」の操作かどうか（ABAC） がチェックされ、それでも該当しなければ基本的に禁止（デフォルト拒否） となります。この複雑な計算結果はキャッシュによって高速化されています。

